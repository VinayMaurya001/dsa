
Course Breakdown
Basics
	Introduction
	Recursion
	Run time Analysis
Physical DS
	Array
	LinkedList
Logical DS
	Tree
	Hashing
	Stack
	Queue
	Graph
Miscelleneous Topics
	Sorting
Algo Techniques
	Magic Framework
	Greedy Algorithm
	Divide & Conquer
	Dynamic Programming


1)
What is DS
	DS is a way to organize the data in a way that enables it to be processed efficiently.
	Analogy
		Basket with fruits

Common DS
	Array
	LinkedList
	Stack
	Queue
		Autograph queue for actor
	Tree
		Family tree
	Graph
		Travelling Salesman Problem
	Hashing etc

Types of DS
	Primitive DS
		Integer
		Float
		Character
		Boolean
	Non-primitive DS
		Physics DS
			Array 
			LinkedList
		Logical DS
			Stack
			Queue
			Tree
			Graph
			Hashing




2)
Recursion
Properties of recursion
	Some operation performed multiple times with diff input
	In every steps,we try to make the problem smaller
	There must be a base condition for ending the recursion.

Why Recursion?
	Sometimes recursion makes easy to write by break down into sub-problems
	Because it is heavily used in DS like tree, graph etc.
	It is heavilly used in techniques like Greedy Algorithm,Divide & Conquer,Dynamic Programming

Format of Recursive function
	Base Case
	Recursive Case

Recursion vs Iteration
Any problem that can be solved using recursion, that can also be solved using iteration.
Space efficient:iteration>Recursion
Time efficient:iteration>Recursion
Ease of code to solve sub-problems:Recursion> iteration



When to use/avoid recursion?
When to use:
	When we can easily brekdown a problem into similar subproblems
	When we are ok with extra overhead (both space & time ) that comes with it
	When we need a quick working solution instead of efficient one.
When to use?
	If response to any of the above 3 statements  is NO, then we should avoid recursion.

Practical use of recursion
	Stack
	Tree:Traversal/Searching/Insertion/Deletion
	Sorting:Quick Sort, Merge Sort
	Divide & Concquer
	Dynamic Programming
	etc


3)
Algorithm Run time Analysis
It is a study of a given algorithm's runnint time, by identifying its behaviour as the input size for the algorithm increases.

Why we need to learn it?
To measure the efficiency of algorithm.

Notations
Analogy: Car

Big O: Upper bound, like software for air bag in car

Omega O: Lower bound, for allocating resources

Theta:On an average
	Whether upper & lower bound is same or not

Example:
	Linear search: 
		Big-o: O(n)
		Omega-o: O(1)
		Theta-o: O(n\2)

Algorithm run time complexities
	O(1)		Constant			Addding an element at front of linked list
	O(log n)	Logarithmic			Finding an element in sorted array
	O(n)		Linear				Finding an element in unsorted array
	O(nlog n)	Linear Logarithmic	Merge Sort
	O(n^2)		Quardatic			Shortest path b/w 2 nodes in a graph
	O(n^3)		Cubic				Matrix Multiplication
	O(2^n)		Exponential			Tower of Hanoi

Finding Runtime Complexities of Iterative Algo
	O(n)=O(n-1)=O(2*n)
	O(1)=O(1000)
Finding Runtime Complexities of Recursive Algo
	Udemy:S02,L06,L07:DSA
	Back Substitution
	Master Theorem

