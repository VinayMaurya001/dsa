4.1 What is a Stack?
A stack is a simple data structure used for storing data (similar to Linked Lists). 

Definition: A stack is an ordered list in which insertion and deletion are done at one end, called top. 
The last element inserted is the first one to be deleted. 
Hence, it is called the Last in First out (LIFO) or First in Last out (FILO) list.

When an element is inserted in a stack, the concept is called push, and when an element is removed from the stack, the concept is called pop
Trying to pop out an empty stack is called underflow and trying to push an element in a full stack is called overflow. Generally, we treat them as exceptions.

4.2 How Stacks are used

4.3 Stack ADT
The following operations make a stack an ADT. For simplicity, assume the data is an integer type.
Main stack operations
• void push(int data): Inserts data onto stack.
• int pop(): Removes and returns the last inserted element from the stack.

Auxiliary stack operations
• int Top(): Returns the last inserted element without removing it.
• int Size(): Returns the number of elements stored in the stack.
• int IsEmptyStack(): Indicates whether any elements are stored in the stack or not.
• int IsFullStack(): Indicates whether the stack is full or not.

4.4 Exceptions
Attempting the execution of an operation may sometimes cause an error condition, called an
exception. Exceptions are said to be “thrown” by an operation that cannot be executed. In the
Stack ADT, operations pop and top cannot be performed if the stack is empty. Attempting the
execution of pop (top) on an empty stack throws an exception. Trying to push an element in a full
stack throws an exception.

4.5 Applications
Following are some of the applications in which stacks play an important role.
Direct applications
• Balancing of symbols
• Infix-to-postfix conversion
• Evaluation of postfix expression
• Implementing function calls (including recursion)
• Finding of spans (finding spans in stock markets, refer to Problems section)
• Page-visited history in a Web browser [Back Buttons]
• Undo sequence in a text editor
• Matching Tags in HTMLand XML
Indirect applications
• Auxiliary data structure for other algorithms (Example: Tree traversal algorithms)
• Component of other data structures (Example: Simulating queues, refer Queues chapter)


4.6 Implementation
There are many ways of implementing stack ADT; below are the commonly used methods.
• Simple array based implementation
• Dynamic array based implementation
• Linked lists implementation

Simple array based implementation
Performance & Limitations
Performance: Let n be the number of elements in the stack. The complexities of stack operations
with this representation can be given as:
Space Complexity (for n push operations) O(n)
Time Complexity of push() O(1)
Time Complexity of pop() O(1)
Time Complexity of size() O(1)
Time Complexity of isEmpty() O(1)
Time Complexity of isFullStack() O(1)
Time Complexity of deleteStack() O(1)
Limitations: The maximum size of the stack must first be defined and it cannot be changed. Trying
to push a new element into a full stack causes an implementation-specific exception.

Dynamic Array Implementation
First, let’s consider how we implemented a simple array based stack. We took one index variable
top which points to the index of the most recently inserted element in the stack. To insert (or push)
an element, we increment top index and then place the new element at that index.
Similarly, to delete (or pop) an element we take the element at top index and then decrement the
top index. We represent an empty queue with top value equal to –1. The issue that still needs to
be resolved is what we do when all the slots in the fixed size array stack are occupied?
First try: What if we increment the size of the array by 1 every time the stack is full?
• Push(); increase size of S[] by 1
• Pop(): decrease size of S[] by 1
Problems with this approach?
This way of incrementing the array size is too expensive. 

Alternative Approach: Repeated Doubling
Let us improve the complexity by using the array doubling technique. 
If the array is full, create a new array of twice the size, and copy the items. 
With this approach, pushing n items takes time proportional to n (not n2).

Performance: Let n be the number of elements in the stack. The complexities for operations with
this representation can be given as:
Space Complexity (for n push operations) O(n)
Time Complexity of create Stack: DynArrayStack () O(1)
Time Complexity of push() O(1) (Average)
Time Complexity of pop() O(1)
Time Complexity of top() O(1)
Time Complexity of isEmpty() O(1)
Time Complexity of isStackFull () O(1)
Time Complexity of deleteStack() O(1)
Note: Too many doublings may cause memory overflow exception.

Linked List Implementation
Performance
Let n be the number of elements in the stack. The complexities for operations with this
representation can be given as:
Space Complexity (for n push operations) O(n)
Time Complexity of create Stack: DynArrayStack() O(1)
Time Complexity of push() O(1) (Average)
Time Complexity of pop() O(1)
Time Complexity of top() O(1)
Time Complexity of isEmpty() O(1)
Time Complexity of deleteStack() O(n)

4.7 Comparison of Implementations
Comparing Incremental Strategy and Doubling Strategy
We compare the incremental strategy and doubling strategy by analyzing the total time T(n)
needed to perform a series of n push operations. We start with an empty stack represented by an
array of size 1. We call amortized time of a push operation is the average time taken by a push
over the series of operations, that is, T(n)/n.
Incremental Strategy: The amortized time (average time per operation) of a push operation is O(n) [O(n2)/n].
Doubling Strategy: In this method, the amortized time of a push operation is O(1) [O(n)/n].
Note: For reasoning, refer to the Implementation section.

Comparing Array Implementation & Linked List Implementation
Array Implementation
• Operations take constant time.
• Expensive doubling operation every once in a while.
• Any sequence of n operations (starting from empty stack) - “amortized” bound takes
time proportional to n.
Linked List Implementation
• Grows and shrinks gracefully.
• Every operation takes constant time O(1).
• Every operation uses extra space and time to deal with references.


4.8 Stacks: Problems & Solutions


Algorithm PUSH
This procedure pushes an ITEM onto a stack.
	1. [stack already filled]
	   if TOP==MAXSTK, then
	   Print OVERFLOW and return.
	2. Set TOP=TOP+1
	3. Set STACK[TOP]=ITEM.
	4. return

Algorithm POP
POP(STACK, TOP, ITEM)
This procedure deletes the top element of STACK and assigns it to the variable ITEM.
	1. [Stack has an item to be removed?]
	   if TOP==-1, then
	   Print: UNDERFLOW and return.
	2. Set ITEM=STACK[TOP]
	3. Set TOP=TOP-1
	4. return

Example: PlateStackTest.java




