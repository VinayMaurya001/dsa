
Why learn AVL tree?
	Depending on incoming data, a Binary Search Tree can get skewed & hence its performance starts going down.
	Instead of O(logn) for insertion/searching/deleting, it can go upto O(n).

	After inserting or deleting node, tree will remain balanced(We will use rotation operation for this).
	Improve performance for operations(like searching) by reducing height.

	Example: 10,20,30,40,50,60

AVL tree
	An AVL tree is a balanced BST where the height of immediate subtree of any node differs by at most one(also called balanced factor).
	
	Height of left subtree~Height of right subtree<=1(balance factor)
	If at any time height differ by more than one , rebalancing(called rotation) is done to restore this property.

	Height of null node=Empty height=-1
	For calculating height of particular node, start 0 from leaf node till particular node.


Common Operations of AVL tree
Creation of tree-Same as BST
Traverse of all nodes-Same as BST
Search for a value-Same as BST
Insertion of a node
Deletion of a node
Deletion of tree-Same as BST

Creation of tree-Same as BST
	Time Complexity O(logn)
	Space Complexity O(logn)
	
Traverse of all nodes-Same as BST
	Depth First Search
		Preorder traversal
		Inorder traversal
		Post order traversal
	Breadth First Search
		Level order traversal
	Time Complexity O(n)
	Space Complexity O(n)

Search for a value-Same as BST

Insertion of a node
Case1:When rotation is not required-Same As BST
	
Case2:When rotation is required(LL,LR,RR,RL)
	Left Left Condition
		From disbalanved node to left ,left to culprit node
		Right Rotation from disbalanced node
	Left Right Condition
		When Left-right node from the current node causing disbalance.
		Left Rotation from left node of from disbalance node
		Right Rotation from disbalance node
	Right Right Condition
		Left Rotation
	Right Left Condition
		Mirror image of Left Right Condition
		Right Rotation from right node of from disbalance node
		Left Rotation from disbalance node

