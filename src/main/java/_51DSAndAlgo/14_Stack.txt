
Logical DS
Stack
Queue
Tree 
Hashing
Graph

Stack
	Bangle in Girl's Hand
	Back Button in browser

Property of stack
	LIFO-Last in first out 
Last in First out (LIFO) or First in Last out (FILO) list.

Trying to pop out an empty stack is called underflow and trying to push an element in a full stack is called overflow. 
Generally, we treat them as exceptions.


Operations on Stack
	Create()
	Push()
	Pop()
	Peek()/top()
	IsEmpty()
	IsFull()
	size()
	DeleteStack()


Stack: LIFO
In computer science, a stack is an ADT that serves as a collection of elements, 
	with two principal operations(Push & Pop) & follow LIFO principle.


Stack Using Array
	Adv
		Easy Implement
	Dis Adv
		Fixed Size

Stack Using Linked List
	Adv
		Variable size
	Dis Adv
		Moderate Implement

Operations on Stack using Array
	Create()
		Time Complexity: O(1)
		Space Complexity: O(n)//Only case out of 7 operation where complexity differ
	Push()
		Time Complexity: O(1)
		Space Complexity: O(1)
	Pop()
		Time Complexity: O(1)
		Space Complexity: O(1)
	Peek()
		Time Complexity: O(1)
		Space Complexity: O(1)
	IsEmpty()
		Time Complexity: O(1)
		Space Complexity: O(1)
	IsFull()
		Time Complexity: O(1)
		Space Complexity: O(1)
	DeleteStack()
		Time Complexity: O(1)
		Space Complexity: O(1)


Operations on Stack using Linked List
	Create()
		Single Linked List
		Time Complexity: O(1)
		Space Complexity: O(1)
	Push()
		Insert at start
		Time Complexity: O(1)
		Space Complexity: O(1)
	Pop()
		delete & return from start
		Time Complexity: O(1)
		Space Complexity: O(1)
	Peek()
		Time Complexity: O(1)
		Space Complexity: O(1)
	IsEmpty()
		Time Complexity: O(1)
		Space Complexity: O(1)
	IsFull()
		Not needed because we can always add element in Linked list
		Although Strictly speckaing complexity is Not applicable 
			Time Complexity: O(1)
			Space Complexity: O(1)
	DeleteStack()
		Time Complexity: O(1)
		Space Complexity: O(1)

Array vs Linked list implementtion of Stack


When to Use/Avoid Stack
When to Use
	1)LIFO 
	2)WHen data need not to be easily curropted (No one can insert/delete data in middle)
When to avoid 
	1)Random acces not possible-If we have done some mistake, its costly to rectify
	

How Stacks are used?

	


Applications
Following are some of the applications in which stacks play an important role.
Direct applications
 Balancing of symbols
 Infix-to-postfix conversion
 Evaluation of postfix expression
 Implementing function calls (including recursion)
 Finding of spans (finding spans in stock markets, refer to Problems section)
 Page-visited history in a Web browser [Back Buttons]
 Undo sequence in a text editor
 Matching Tags in HTMLand XML
Indirect applications
 Auxiliary data structure for other algorithms (Example: Tree traversal algorithms)
 Component of other data structures (Example: Simulating queues, refer Queues chapter)


Implementation
There are many ways of implementing stack ADT; below are the commonly used methods.
 Simple array based implementation
 Dynamic array based implementation
 Linked lists implementation

Simple array based implementation
Performance & Limitations
Performance: Let n be the number of elements in the stack. The complexities of stack operations
with this representation can be given as:
Space Complexity (for n push operations) O(n)
Time Complexity of push() O(1)
Time Complexity of pop() O(1)
Time Complexity of size() O(1)
Time Complexity of isEmpty() O(1)
Time Complexity of isFullStack() O(1)
Time Complexity of deleteStack() O(1)
Limitations: The maximum size of the stack must first be defined and it cannot be changed. Trying
to push a new element into a full stack causes an implementation-specific exception.

Dynamic Array Implementation
First, lets consider how we implemented a simple array based stack. We took one index variable
top which points to the index of the most recently inserted element in the stack. To insert (or push)
an element, we increment top index and then place the new element at that index.
Similarly, to delete (or pop) an element we take the element at top index and then decrement the
top index. We represent an empty queue with top value equal to 1. The issue that still needs to
be resolved is what we do when all the slots in the fixed size array stack are occupied?
First try: What if we increment the size of the array by 1 every time the stack is full?
 Push(); increase size of S[] by 1
 Pop(): decrease size of S[] by 1
Problems with this approach?
This way of incrementing the array size is too expensive. 

Alternative Approach: Repeated Doubling
Let us improve the complexity by using the array doubling technique. 
If the array is full, create a new array of twice the size, and copy the items. 
With this approach, pushing n items takes time proportional to n (not n2).

Performance: Let n be the number of elements in the stack. The complexities for operations with
this representation can be given as:
Space Complexity (for n push operations) O(n)
Time Complexity of create Stack: DynArrayStack () O(1)
Time Complexity of push() O(1) (Average)
Time Complexity of pop() O(1)
Time Complexity of top() O(1)
Time Complexity of isEmpty() O(1)
Time Complexity of isStackFull () O(1)
Time Complexity of deleteStack() O(1)
Note: Too many doublings may cause memory overflow exception.

Linked List Implementation
Performance
Let n be the number of elements in the stack. The complexities for operations with this
representation can be given as:
Space Complexity (for n push operations) O(n)
Time Complexity of create Stack: DynArrayStack() O(1)
Time Complexity of push() O(1) (Average)
Time Complexity of pop() O(1)
Time Complexity of top() O(1)
Time Complexity of isEmpty() O(1)
Time Complexity of deleteStack() O(n)

Comparison of Implementations
Comparing Incremental Strategy and Doubling Strategy
We compare the incremental strategy and doubling strategy by analyzing the total time T(n)
needed to perform a series of n push operations. We start with an empty stack represented by an
array of size 1. We call amortized time of a push operation is the average time taken by a push
over the series of operations, that is, T(n)/n.
Incremental Strategy: The amortized time (average time per operation) of a push operation is O(n) [O(n2)/n].
Doubling Strategy: In this method, the amortized time of a push operation is O(1) [O(n)/n].
Note: For reasoning, refer to the Implementation section.

Comparing Array Implementation & Linked List Implementation
Array Implementation
 Operations take constant time.
 Expensive doubling operation every once in a while.
 Any sequence of n operations (starting from empty stack) - amortized bound takes
time proportional to n.
Linked List Implementation
 Grows and shrinks gracefully.
 Every operation takes constant time O(1).
 Every operation uses extra space and time to deal with references.


4.8 Stacks: Problems & Solutions


Algorithm PUSH
This procedure pushes an ITEM onto a stack.
	1. [stack already filled]
	   if TOP==MAXSTK, then
	   Print OVERFLOW and return.
	2. Set TOP=TOP+1
	3. Set STACK[TOP]=ITEM.
	4. return

Algorithm POP
POP(STACK, TOP, ITEM)
This procedure deletes the top element of STACK and assigns it to the variable ITEM.
	1. [Stack has an item to be removed?]
	   if TOP==-1, then
	   Print: UNDERFLOW and return.
	2. Set ITEM=STACK[TOP]
	3. Set TOP=TOP-1
	4. return

Example: PlateStackTest.java






